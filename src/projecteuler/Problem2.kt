package projecteuler

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class EvenFibonacci {

    /**
     * Even Fibonacci numbers
     *
     * Each new term in the Fibonacci sequence is generated by adding the previous two terms.
     * By starting with 1 and 2, the first 10 terms will be:
     * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
     * By considering the terms in the Fibonacci sequence whose values do not exceed four million,
     * find the sum of the even-valued terms.
     */

    private val fib = Fib()

    /**
     * Tests regarding the function calculating terms on the Fibonacci sequence
     */
    @Test
    fun testFib() {
        assertEquals(0, fib.calculateTerm(0))

        assertEquals(1, fib.calculateTerm(1))

        assertEquals(1, fib.calculateTerm(2))

        assertEquals(2, fib.calculateTerm(3))

        assertEquals(3, fib.calculateTerm(4))

        assertEquals(5, fib.calculateTerm(5))

        assertEquals(8, fib.calculateTerm(6))

        assertEquals(13, fib.calculateTerm(7))

        assertEquals(21, fib.calculateTerm(8))

        assertEquals(34, fib.calculateTerm(9))

        assertEquals(55, fib.calculateTerm(10))
    }

    /**
     * Since the even terms not exceeding 10 in the sequence are 2 and 8,
     * then the expected value is 2 + 8 = 10
     */
    @Test
    fun testTermsNotExceeding10() {
        fib.calculateUntil(10)
        val sumOfEvens = fib.calculated.filter { it % 2 == 0 }.sum()
        assertEquals(10, sumOfEvens)
    }

    /**
     * The expected value of this test is the solution to the problem
     */
    @Test
    fun testTermsNotExceeding4Million() {
        fib.calculateUntil(4000000)
        val sumOfEvens = fib.calculated.filter { it % 2 == 0 }.sum()
        assertEquals(4613732, sumOfEvens)
    }
}

class Fib {
    /**
     * This is a memoized implementation of the function calculating the Fibonacci seq.
     * The list "calculated" starts with the first two terms of the sequence and grows to hold
     * new terms as calculated by the method "calculateTerm" below.
     */
    val calculated = listOf(0, 1).toMutableList()

    /**
     * Calculates the n-th term in the sequence and the ones below it that aren't on "calculated".
     * Returns the last item on "calculated".
     */
    fun calculateTerm(n: Int): Int {
        /**
         * If we have more calculated terms than the requested index, we return the calculated one.
         */
        return if (calculated.size > n) {
            calculated[n]
        } else {
            /**
             * Otherwise we calculate the missing terms until the requested one (n-th).
             * We begin from the last calculated term we have and proceed to compute the others.
             */
            var i = calculated.size
            while (i <= n) {
                val current = calculated[i - 1] + calculated[i - 2]
                calculated.add(current)
                i++
            }
            return calculated.last()
        }
    }

    /**
     * Calculates Fibonacci terms using "calculateTerm" above until the value of the term is greater
     * than or equal to the parameter "value".
     * Returns the last item on "calculated".
     */
    fun calculateUntil(value: Int): Int {
        var i = 0
        do {
            val currentValue = calculateTerm(i)
            i++
        } while (currentValue < value)
        return calculated.last()
    }

}